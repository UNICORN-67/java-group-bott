const fs = require('fs');
const path = require('path');

module.exports = async (ctx, db, OWNER_ID) => {
    // 1. Authorization Check (Owner & Sudo)
    const sudoList = await db.collection('sudo_users').distinct('uid');
    const isOwner = (ctx.from.id === OWNER_ID);
    const isSudo = sudoList.includes(ctx.from.id.toString());

    if (!isOwner && !isSudo) {
        return ctx.reply("‚ùå ·¥Ä·¥Ñ·¥Ñ·¥áÍú±Íú± ·¥Ö·¥á…¥…™·¥á·¥Ö:  è·¥è·¥ú …¥·¥á·¥á·¥Ö Íú±·¥ú·¥Ö·¥è/·¥è·¥°…¥·¥á Ä ·¥ò·¥á Ä·¥ç…™Íú±Íú±…™·¥è…¥Íú±.");
    }

    // 2. Target Identification
    const target = ctx.message.reply_to_message ? ctx.message.reply_to_message.from : null;
    if (!target) {
        return ctx.reply("‚ö†Ô∏è ·¥ò ü·¥á·¥Äs·¥á  Ä·¥á·¥ò ü è ·¥õ·¥è ·¥Ä ·¥ús·¥á Ä's ·¥ç·¥áss·¥Ä…¢·¥á ·¥õ·¥è ·¥õ Ä·¥Ä·¥Ñ·¥á ·¥õ ú·¥á·¥ç.");
    }

    const uid = target.id.toString();
    const name = target.first_name;

    // 3. Data Extraction (Merging multiple collections)
    const history = await db.collection('user_history').findOne({ uid });
    const globalData = await db.collection('global_users').findOne({ uid });

    // 4. Report Building
    let log = `====================================\n`;
    log += `   üïµÔ∏è‚Äç‚ôÇÔ∏è YURI AI INVESTIGATION REPORT   \n`;
    log += `====================================\n\n`;
    
    log += `[BASIC INFO]\n`;
    log += `‚Ä¢ User ID: ${uid}\n`;
    log += `‚Ä¢ Name: ${name} ${target.last_name || ""}\n`;
    log += `‚Ä¢ Username: @${target.username || "N/A"}\n`;
    log += `‚Ä¢ Status: ${target.is_bot ? "ü§ñ BOT" : "üë§ HUMAN"}\n\n`;

    if (history) {
        log += `[IDENTITY LOGS (Sangmata Core)]\n`;
        log += `‚Ä¢ Known Names: ${history.names.join(' | ')}\n`;
        log += `‚Ä¢ Known Usernames: ${history.usernames.join(' | ')}\n\n`;
    }

    if (globalData) {
        log += `[GLOBAL FOOTPRINTS]\n`;
        log += `‚Ä¢ Total Messages: ${globalData.total_messages || 0}\n`;
        log += `‚Ä¢ Last Activity: ${globalData.last_seen}\n`;
        log += `‚Ä¢ Visible Groups:\n`;
        
        if (globalData.seen_in_groups && globalData.seen_in_groups.length > 0) {
            globalData.seen_in_groups.forEach(g => {
                log += `  - [${g.gid}] ${g.gName}\n`;
            });
        } else {
            log += `  - No specific group records found.\n`;
        }
    } else {
        log += `[ALERT]: No global database entry found. Target is possibly a ghost or new.\n`;
    }

    log += `\n====================================\n`;
    log += `REPORT GENERATED BY YURI AI | SYSTEM: ENCRYPTED\n`;
    log += `====================================`;

    // 5. File Handling (Vercel Friendly)
    const fileName = `TRACE_${uid}_${Date.now()}.txt`;
    const filePath = path.join('/tmp', fileName);

    try {
        fs.writeFileSync(filePath, log);

        // Sending Document
        await ctx.replyWithDocument(
            { source: filePath, filename: fileName },
            { 
                caption: `üîç <b>·¥Ö·¥á·¥á·¥ò ·¥õ Ä·¥Ä·¥Ñ·¥á ·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á·¥Ö</b>\nüë§ ·¥õ·¥Ä Ä…¢·¥á·¥õ: <code>${name}</code>\nüÜî …™·¥Ö: <code>${uid}</code>`,
                parse_mode: 'HTML' 
            }
        );
    } catch (err) {
        console.error("Tracing Error:", err);
        ctx.reply("‚ùå Error generating trace file.");
    } finally {
        // Clean up file from /tmp
        if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
    }
};
